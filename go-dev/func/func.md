# 函数
>一组指令集封装，Go语言函数有以下特点：
1. 无需前置声明
1. 不支持命名嵌套定义(嵌套函数)
1. 不支持同名函数
1. 不支持默认参数(参考py,py可以定义默认参数，当调用不传递参数时，使用参数预置定义的值)
1. 支持可变参数
1. 支持多值返回
1. 支持命名返回值
1. 支持匿名函数和闭包

## Go函数签名
>参数列表和返回值列表一致

## 函数类型
>函数是一种未命名类型，指定参数列表，返回值列表后，可作为一种明确的函数类型
1. 具有相同函数签名的Go函数(不考虑名称)可视为同一种函数类型
1. 函数也被称为`first-class object`：可在运行时创建，可以作为函数参数和返回值(函数值)

## 函数类型声明语法
>`type {func_name} func({param_list}) {return_list}`(参考go-dev/func/func.go#MyFunc)

## 注意点
1. 函数只能与nil做判断：`func == nil or func != nil`，不支持函数与函数比较`func1 == func2 编译失败`(参考go-dev/func/func.go#Demo1)
1. 函数可以返回函数自身局部变量指针，编译器会根据逃逸分析技术将该局部变量分配到堆(参考go-dev/func/func.go#func3)

## 函数名命名规则
>建议`camel/pascal case(相对于驼峰差别在于首字母大写)`

## 参数
>Go语言的函数调用都是`pass-by-value`：值传递(copy一份实参传递给函数)
1. 对于大类型数据一定要注意copy的成本
1. 使用指针替代也是一个办法，但不是最好的，需要注意一点：
    1. 当一个函数的局部变量通过指针给另一个函数时会发生逃逸，考虑到分配堆和回收的开销，得不偿失
    1. 当前局部变量因为指针指向，而不会被及时回收造成声明周期延长
    1. 仅在复制成本不高的情况下使用指针最佳
1. 从Go的传值上可以看出Go语言应该是优先栈帧分配???
1. Go语言可以通过二级指针并且不使用return实现函数局部变量返回(参考go-dev/func/func.go#Demo3)
1. 参数列表过长，可以封装到一个结构体中
1. 相同类型，相邻参数可以合并

### 可变参数
>`func test(a int,b...string)`：只能作为参数列表最后一位，并且只支持一种类型，本质是切片(参考go-dev/func/func.go#Demo4)
1. 本质是切片，但是传递切片给可变参数是不可以的，必须展开

## 返回值
1. 支持多值返回`func test() (type1,type2...typen)`
1. 支持命名返回值`func test() (name1 type1...namen,typen)`
    * 有助于改善doc
    * 返回值可以作为局部变量参与业务，最终使用return结束(这里的return支持2种形式，不可混合使用；参考go-dev/func/func.go#Demo5)
    * 一旦命名 ，所有返回值都要命名
    * 返回值的名称不会被局部变量遮蔽，原因是Go编译器会检测，发现被遮蔽就编译失败
    * 不推荐使用
 
 ## 匿名函数
 >没有名称的函数，可以被嵌套使用
 
 ## 闭包
 >函数记住其所诞生的环境，Go语言的闭包底层是通过编译器编译插入指针完成的。这样会导致闭包的变量生命周期及内存分配发生变化(参考go-dev/func/func.go#Demo6)
 1. 闭包只会记住自己诞生的环境(被自己捕获的变量)，并不记录自己内部的环境
 1. 闭包的性能不高
 
 ## 延迟调用
 